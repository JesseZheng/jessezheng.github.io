<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[台湾行-计划记录]]></title>
    <url>%2F2019%2F06%2F27%2F%E5%8F%B0%E6%B9%BE%E8%A1%8C-%E8%AE%A1%E5%88%92%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前期准备 两签一注（台湾通行证+个人旅游G签注+入台证） 台湾通行证+签注（需要一周）：出在入境办事大厅办理 入台证（需要一周）：在淘宝飞猪上自助购买或者找旅行社，前提是有台湾通行证及签注 机票 提前看机票，飞猪，旅游旺季机票特别贵 交通工具 悠游卡（捷运，公交等交通工具通用） 火车票（高铁或台铁） 拼车 台湾环岛路线规划（11天10晚） 7月23日 出发 上海虹桥-&gt;台北松山 8月2日 返回 台北松山-&gt;上海虹桥 环岛路线参考了马蜂窝上的攻略-台湾10天9夜顺时针环岛自由行攻略 台北 - 花莲 - 垦丁 - 高雄 - 台中 - 台北 台湾行费用表 Day1 · 7.23 - 台北 台北象山观光 台北101 西门町 宁夏夜市，士林夜市 住宿：台北 Day2 · 7.24 - 平溪一日游 台北车站 - 瑞芳站 - 平溪线 - 九份 十分放天灯 猫村猴硐 九份老街 台北Vlog 住宿：台北 Day3 · 7.25 - 淡水 -&gt; 前往花莲 淡水中学（不能说的秘密） 渔人码头 淡水老街 交通：台铁 住宿：花莲 Day4 · 7.26 - 花莲一日游 赏鲸 新天地乐园 东大门夜市 马蜂窝包车 住宿：花莲 Day5 · 7.27 - 花莲 -&gt; 前往垦丁 马蜂窝包车 花莲Vlog 住宿：垦丁 Day6 · 7.28 - 垦丁一日游 住宿：垦丁 Day7 · 7.29 - 垦丁 -&gt; 前往高雄 包车 住宿：高雄 Day8 · 7.30 - 高雄 -&gt; 前往台中 逢甲夜市 逢甲大学 交通：高铁 住宿：台中 Day9 · 7.31 - 高美湿地 高美湿地 东海大学 彩虹眷村 混子Vlog 住宿：台中 Day10 · 8.1 自由安排 -&gt; 台北 交通：高铁 住宿：台北 Day11 · 8.2 - 台北自由安排 -&gt; 回家]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>台湾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSE-LECTURE2-TRUESEC]]></title>
    <url>%2F2019%2F01%2F30%2FSSE-LECTURE2-TRUESEC%2F</url>
    <content type="text"><![CDATA[Validation always prefer white listing, before black listing always prefer strict validation normaliztion and sanitation is for edge cases only! Untrusted Pattern highlight the trust boundary less intrusive to existing code Implementation - Immutability Drastically reduce the risk of TOCTTOU problems Increases readability Increases parallelism Increases event sourcing Implementation - Pessimistic StrategyImplementation - Isolate risks compartmentalize sensitive operations Risk separation: Parsing of certain formats(XML), consider external dependencies Security testing]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Secure Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSE-Ethics]]></title>
    <url>%2F2019%2F01%2F28%2FSSE-Ethics%2F</url>
    <content type="text"><![CDATA[Technology Technology good, evil or neutral? The effect of tech; damage effects Classification Technology development inevitable Resistance and political control Netiquette write shortly …… The engineer From slave/military to civil engineer in society Professional ethics in addition to a general ethics Social roles with moral obligations Occuaptional-specific ethical problems Respinsibility task responsibilities - to get things done debt responsibilities - who to blame ambient(环境) responsibility Loyalty and ethical codes the limits of loyalty vs environmental / safety reuquirements misguided loyalty “whistle-blower” Engineering codes to be filled Ethics for developers contribute to society and hume welfare avoid damging other - coding errors, security issues, follow standards design and test honest and trustworthy - admit your limitaions and report potential risks give credit to the author respect the privavy of others be sure of confidentiality Technology Assessment detect future consequences of new technology in advance medical technology evaluation environmental impact assessment risk analysis Assignment 1-2 pages single spacing, 12-14 font size]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Secure Software Engineering</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple HTTP webserver]]></title>
    <url>%2F2018%2F11%2F04%2FSimple-HTTP-webserver%2F</url>
    <content type="text"><![CDATA[Github: TinyServer SocketBindListenAcceptForkDeamon process Reference Linux Socket编程]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>http-webserver</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell命令自查]]></title>
    <url>%2F2018%2F09%2F13%2Fshell%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[getopts grep &amp;&amp; egrep $读取命令行参数 chmod sort uniq wc cut getopts 1234567891011121314151617#!/bin/bash while getopts "a:b:cdef" opt; do case $opt in a) echo "this is -a the arg is ! $OPTARG" ;; b) echo "this is -b the arg is ! $OPTARG" ;; c) echo "this is -c the arg is ! $OPTARG" ;; \?) echo "Invalid option: -$OPTARG" ;; esac getopts的使用形式是：getopts option_string variable getopts一共有两个参数，test.sh -a hello第一个是-a这样的选项，第二个参数是 hello这样的参数。 option_string之间可以直接相连，把:加在某个选项后面表示这个选项必须带有参数 例如：getopts ahfvc: option表明选项a、h、f、v可以不加实际值进行传递，而选项c必须取值。使用选项取值时，必须使用变量OPTARG保存该值。 grep grep命令使用正则表达式来搜索文本，并且把匹配的文本打印出来。 grep [options]pattern [file] option表示选项，pattern表示匹配的模式。file表示一系列文件名。 常用选项： -c 只打印匹配的文本行的函数，不显示文本内容。 -i 匹配时忽略字母大小写 -h 当搜索多个文件，不显示匹配文件名前缀。 -l 只列出含义匹配的文本行的文件的文件名，不显示其具体匹配的内容。 -n 列出所有匹配的文本行，并显示行号 -s 不显示关于不存在或无法读取文件的错误信息 -v 只显示不匹配的文本行。 -w 匹配整个单词 -x 匹配整个文本行 -r 递归搜索，不仅搜索当前目录，还有各级子目录 -q 用于if逻辑判断 -q 参数，本意是 Quiet; do not write anything to standard output. Exit immediately with zero status if any match is found, even if an error was detected. 中文意思为，安静模式，不打印任何标准输出。如果有匹配的内容则立即返回状态值0。 正则表达式 1）行首定位符 “^” 用来匹配行首的字符。表示行首的字符是^后面的那个字符。 行首定位符位于所作用的字符之前 例如： 123#列出/etc目录中的以字母po开头的文件名str=`ls /etc | grep "^po"`echo"$str" 2）行尾定位符”$” 作用：定位文本行的末尾。 行尾定位符位于所作用的字符之后。 123#列出/etc目录中以conf结尾的文件名str=`ls /etc | grep "conf$"`echo"$str" 精确匹配一个文本行：^cat$ 完全匹配cat的文本行 ^$:匹配所有空行 单独的^和$没有任何意义，因为任何一个文本行都有开头和结尾。 3）单个字符匹配”.” 圆点.用来匹配任意单个字符。包括空格，但不包括换行符\n。当使用.后，意味着该位置一定有一个字符，无论他是什么字符。 (可以连续使用..来匹配多个字符，如l..p，匹配含义字母l，然后是两个任意字符，再接着是字母p的字符串) 4） 限定符“*” 限定符本身不代表任何字符，用来指定其前面的一个字符必须重复出现多次才能满足匹配。而星号表示匹配其前导字符的任意次数，包括0次。 5） 字符集匹配“[]” 只要某个字符串在方括号所在的位置上出现了方括号中的任意一个字符，就满足匹配规则。 对于连续的数字或字母，可使用连字符-来表示一个范围。 如：[a-f]表示匹配a到f中的任意一个字母 [0-9]匹配任意单个数字 6）字符集不匹配“[^]” egrep (egrep命令默认使用扩展正则表达式) 1 ）限定符“+” “+”限定前面的字符至少出现一次。 #筛选以字符串“ss”开头，后面至少紧跟着1个字符“s”的文本行 123#筛选以字符串“ss”开头，后面至少紧跟着1个字符“s”的文本行str=ls /etc | egrep "^sss+"echo"$str" 结果：sssd 2）限定符“？” 限定前面的字符最多只出现一次。 123#筛选以字符串“ss”开头，后面跟着0或者1个s的文本行str=ls /etc |egrep "^sss?"echo"$str" 结果：ssh,ssl,sssd 3）竖线“|”和圆括号“()” 竖线|表示多个正则表达式之前或的关系 圆括号表示一组可选值得集合。 竖线和圆括号经常一起使用，表示一组可选值。 123#筛选含有字符串“ssh”、“ssl”或者以字符串“yum”开头的文本行str=ls /etc |egrep "(ssh|ssl|^yum)"echo"$str" $读取命令行参数 123456789101112131415161718#all params 全部参数echo $@#all params 全部参数echo $*#length of params 参数的长度echo $##first param 第一个参数echo $1#last param 最后一个参数echo $&#123;@:$&#123;#@&#125;&#125;#last 2 param 最后两个参数echo $&#123;@:$&#123;#@&#125;-1&#125;#last 2nd param 倒数第二个参数echo $&#123;@:$&#123;#@&#125;-1:1&#125;#from 2nd to last param 从第二个到最后一个参数echo $&#123;@:2&#125;#from 2nd, count 2 从第2个参数开始，连续2个参数echo $&#123;@:2:2&#125; chmod chmod [可选项] &lt;file…&gt; 123456789101112131415161718192021222324可选项： -c, --changes like verbose but report only when a change is made (若该档案权限确实已经更改，才显示其更改动作) -f, --silent, --quiet suppress most error messages （若该档案权限无法被更改也不要显示错误讯息） -v, --verbose output a diagnostic for every file processed（显示权限变更的详细资料） --no-preserve-root do not treat '/' specially (the default) --preserve-root fail to operate recursively on '/' --reference=RFILE use RFILE‘s mode instead of MODE values -R, --recursive change files and directories recursively （以递归的方式对目前目录下的所有档案与子目录进行相同的权限变更) --help 显示此帮助信息 --version 显示版本信息mode ：权限设定字串，详细格式如下 ：[ugoa...][[+-=][rwxX]...][,...]， 其中[ugoa...]u 表示该档案的拥有者，g 表示与该档案的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示所有（包含上面三者）。[+-=]+ 表示增加权限，- 表示取消权限，= 表示唯一设定权限。[rwxX]r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该档案是个子目录或者该档案已经被设定过为可执行。 file...文件列表（单个或者多个文件、文件夹） 数字权限使用格式在这种使用方式中，首先我们需要了解数字如何表示权限。 首先，我们规定 数字 4 、2 和 1表示读、写、执行权限（具体原因可见下节权限详解内容），即 r=4，w=2，x=1 。此时其他的权限组合也可以用其他的八进制数字表示出来，如： rwx = 4 + 2 + 1 = 7 rw = 4 + 2 = 6 rx = 4 +1 = 5 即 若要同时设置 rwx (可读写运行） 权限则将该权限位 设置 为 4 + 2 + 1 = 7 若要同时设置 rw- （可读写不可运行）权限则将该权限位 设置 为 4 + 2 = 6 若要同时设置 r-x （可读可运行不可写）权限则将该权限位 设置 为 4 +1 = 5 上面我们提到，每个文件都可以针对三个粒度，设置不同的rwx(读写执行)权限。即我们可以用用三个8进制数字分别表示 拥有者 、群组 、其它组( u、 g 、o)的权限详情，并用chmod直接加三个8进制数字的方式直接改变文件权限。语法格式为 ：chmod &lt;abc&gt; file... 12345其中a,b,c各为一个数字，分别代表User、Group、及Other的权限。相当于简化版的chmod u=权限,g=权限,o=权限 file...而此处的权限将用8进制的数字来表示User、Group、及Other的读、写、执行权限 范例： 设置所有人可以读写及执行 1chmod 777 file (等价于 chmod u=rwx,g=rwx,o=rwx file 或 chmod a=rwx file) 设置拥有者可读写，其他人不可读写执行 1chmod 600 file (等价于 chmod u=rw,g=---,o=--- file 或 chmod u=rw,go-rwx file ) 常见的权限表示形式有： 123456789101112131415161718192021222324252627-rw------- (600) 只有拥有者有读写权限。-rw-r--r-- (644) 只有拥有者有读写权限；而属组用户和其他用户只有读权限。-rwx------ (700) 只有拥有者有读、写、执行权限。-rwxr-xr-x (755) 拥有者有读、写、执行权限；而属组用户和其他用户只有读、执行权限。-rwx--x--x (711) 拥有者有读、写、执行权限；而属组用户和其他用户只有执行权限。-rw-rw-rw- (666) 所有用户都有文件读、写权限。-rwxrwxrwx (777) 所有用户都有读、写、执行权限。# 实际上，后九位每个位置的意义（代表某个属组的某个权限）都是固定的，如果我们将各个位置权限的有无用二进制数 1和 0来代替，则只读、只写、只执行权限，可以用三位二进制数表示为r-- = 100-w- = 010--x = 001--- = 000# 实际上，我们可以将所有的权限用二进制形式表现出来，并进一步转变成八进制数字rwx = 111 = 7rw- = 110 = 6r-x = 101 = 5r-- = 100 = 4-wx = 011 = 3-w- = 010 = 2--x = 001 = 1--- = 000 = 0-rw------- = 600-rw-rw-rw- = 666-rwxrwxrwx = 777 关于第一位最高位的解释： 上面我们说到了权限表示中后九位的含义，剩下的第一位代表的是文件的类型，类型可以是下面几个中的一个： 1234567d代表的是目录(directroy)-代表的是文件(regular file)s代表的是套字文件(socket)p代表的管道文件(pipe)或命名管道文件(named pipe)l代表的是符号链接文件(symbolic link)b代表的是该文件是面向块的设备文件(block-oriented device file)c代表的是该文件是面向字符的设备文件(charcter-oriented device file) sort 1) sort的工作原理 sort将文件的每一行作为一个单位，相互比较，比较原则是从首字符向后，依次按ASCII码值进行比较，最后将他们按升序输出。 2) sort的-u选项 输出行中去除重复行。 3) sort的-r选项 sort默认的排序方式是升序，如果想改成降序，就加个-r就搞定了。 4) sort的-o选项 由于sort默认是把结果输出到标准输出，所以需要用重定向才能将结果写入文件，形如sort filename &gt; newfile。 但是，如果你想把排序结果输出到原文件中，用重定向可就不行了。 123[rocrocket@rocrocket programming]$ sort -r number.txt &gt; number.txt[rocrocket@rocrocket programming]$ cat number.txt[rocrocket@rocrocket programming]$ 看，竟然将number清空了。 就在这个时候，-o选项出现了，它成功的解决了这个问题，让你放心的将结果写入原文件。这或许也是-o比重定向的唯一优势所在。 1234567[rocrocket@rocrocket programming]$ sort -r number.txt -o number.txt[rocrocket@rocrocket programming]$ cat number.txt54321 5) sort的-n选项 你有没有遇到过10比2小的情况。我反正遇到过。出现这种情况是由于排序程序将这些数字按字符来排序了，排序程序会先比较1和2，显然1小，所以就将10放在2前面喽。这也是sort的一贯作风。 我们如果想改变这种现状，就要使用-n选项，来告诉sort，“要以数值来排序”！ 6) sort的-t选项和-k选项 如果有一个文件的内容是这样： 12345[rocrocket@rocrocket programming]$ cat facebook.txtbanana:30:5.5apple:10:2.5pear:90:2.3orange:20:3.4 这个文件有三列，列与列之间用冒号隔开了，第一列表示水果类型，第二列表示水果数量，第三列表示水果价格。 那么我想以水果数量来排序，也就是以第二列来排序，如何利用sort实现？ 幸好，sort提供了-t选项，后面可以设定间隔符。（是不是想起了cut和paste的-d选项，共鸣～～） 指定了间隔符之后，就可以用-k来指定列数了。 12345[rocrocket@rocrocket programming]$ sort -n -k 2 -t : facebook.txtapple:10:2.5orange:20:3.4banana:30:5.5pear:90:2.3 我们使用冒号作为间隔符，并针对第二列来进行数值升序排序，结果很令人满意。 uniq 123456789101112131415用法：uniq [选项]... [文件] 从输入文件或者标准输入中筛选相邻的匹配行并写入到输出文件或标准输出。 不附加任何选项时匹配行将在首次出现处被合并。 长选项必须使用的参数对于短选项时也是必需使用的。 -c, --count //在每行前加上表示相应行目出现次数的前缀编号 -d, --repeated //只输出重复的行 -D, --all-repeated //只输出重复的行，不过有几行输出几行 -f, --skip-fields=N //-f 忽略的段数，-f 1 忽略第一段 -i, --ignore-case //不区分大小写 -s, --skip-chars=N //根-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, --unique //去除重复的后，全部显示出来，根mysql的distinct功能上有点像 -z, --zero-terminated end lines with 0 byte, not newline -w, --check-chars=N //对每行第N 个字符以后的内容不作对照 --help //显示此帮助信息并退出 --version //显示版本信息并退出 wc 1wc [-clw][--help][--version][文件...] -c或–bytes或–chars 只显示Bytes数。 -l或–lines 只显示行数。 -w或–words 只显示字数。 –help 在线帮助。 –version 显示版本信息。 cut 1cut -c -b -f -d -s -c character -b byte -f field -d delimiter分隔符 -c 和 -f 参数可以跟以下子参数： N 第N个字符或字段 N- 从第一个字符或字段到文件结束 N-M 从第N个到第M个字符或字段 -M 从第一个到第N个字符或字段 参考资料shell getopts 用法 《sort帮你排序》-linux命令五分钟系列之二十六 作者 roc) Linux权限详解（chmod、600、644、666、700、711、755、777、4755、6755、7755） shell之正则表达式]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【教程】CPH机场购买前往Karlskrona的火车票]]></title>
    <url>%2F2018%2F09%2F07%2FCPH%E8%B4%AD%E4%B9%B0%E5%89%8D%E5%BE%80Karlskrona%E7%9A%84%E7%81%AB%E8%BD%A6%E7%A5%A8%2F</url>
    <content type="text"><![CDATA[………… 从机场取好行李，然后出口 找到前往Sweden的火车票购票机器(不是图一右边的购票机器！是左边的机器，上面写前往Sweden) Step1 - Destination选择Karlskrona Step2 - 选择over the bridge Step3 - 支付方式credit Step4 - 票的类型可以选family（2人票）便宜一些，如果人数是单数的话一个人选adult Step5 - 支付成功后会有一张车票吐出来，车票要保管好，火车上会查票（family票两人一组） 进站口是图上圈的这个1号口 火车上尽量找车厢靠前的位置，因为中途火车可能会断掉偏后的一些车厢，只有部分车厢到达卡村，可以选择在两个站下车（Karlskrona Central Station靠近市中心，Bergåsa station靠近学校）]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>瑞典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-4.Median of Two Sorted Arrays]]></title>
    <url>%2F2018%2F08%2F10%2Fleetcode-4-Median-of-Two-Sorted-Arrays%2F</url>
    <content type="text"><![CDATA[There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. 思路题目是让我们求两个数组的中位数，如果没有时间复杂度限制条件的话，最简单好理解的方法是：把两个数组merge成一个sorted array，然后判断数组的长度的奇偶后直接可以得出中位数。 不过题目设置了时间复杂度O(log(m+n))，m和n分别是两个数组的长度。因此题目变得复杂了，这边我主要介绍一种我认为相对好理解的解法。 该方法的核心是将原问题转变成一个寻找第k小数的问题（假设两个原序列升序排列），这样中位数实际上是第(m+n)/2小的数。所以只要解决了第k小数的问题，原问题也得以解决。 首先假设数组A和B的元素个数都大于k/2，我们比较A[k/2-1]和B[k/2-1]两个元素，这两个元素分别表示A的第k/2小的元素和B的第k/2小的元素。这两个元素比较共有三种情况：&gt;、&lt;和=。 如果A[k/2-1]&lt;B[k/2-1]，这表示A[0]到A[k/2-1]的元素都在A和B合并之后的前k小的元素中。换句话说，A[k/2-1]不可能大于两数组合并之后的第k小值，所以我们可以将其抛弃。 当A[k/2-1]&gt;B[k/2-1]时存在类似的结论。 当A[k/2-1]=B[k/2-1]时，我们已经找到了第k小的数，也即这个相等的元素，我们将其记为m。由于在A和B中分别有k/2-1个元素小于m，所以m即是第k小的数。(这里可能有人会有疑问，如果k为奇数，则m不是中位数。这里是进行了理想化考虑，在实际代码中略有不同，是先求k/2，然后利用k-k/2获得另一个数。) 通过上面的分析，我们即可以采用递归的方式实现寻找第k小的数。此外我们还需要考虑几个边界条件： 如果A或者B为空，则直接返回B[k-1]或者A[k-1]； 如果k为1，我们只需要返回A[0]和B[0]中的较小值； 如果A[k/2-1]=B[k/2-1]，返回其中一个； 代码123456789101112131415161718192021222324252627282930def findKth(nums1, m, nums2, n, k): if m&gt;n: return findKth(nums2, n, nums1, m, k) if m==0: return nums2[k-1] if k==1: return min(nums1[0], nums2[0]) pa = min(k//2, m) pb = k - pa if nums1[pa-1]&lt;nums2[pb-1]: return findKth(nums1[pa:], m-pa, nums2, n, k-pa) elif nums1[pa-1]&gt;nums2[pb-1]: return findKth(nums1, m, nums2[pb:], n-pb, k-pb) else: return nums1[pa-1] class Solution: def findMedianSortedArrays(nums1, nums2): """ :type nums1: List[int] :type nums2: List[int] :rtype: float """ m = len(nums1) n = len(nums2) k = (m+n)//2 if (m+n)%2 == 0: return (findKth(nums1, m, nums2, n, k)+findKth(nums1, m, nums2, n, k+1))/2 else: return findKth(nums1, m, nums2, n, k+1) 参考资料：leetcode之 median of two sorted arrays - CSDN博客]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解RESTful架构]]></title>
    <url>%2F2018%2F07%2F17%2F%E7%90%86%E8%A7%A3RESTful%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[（转载）理解RESTful架构 - 阮一峰的网络日志 起源 REST这个词，是Roy Thomas Fielding在他2000年的博士论文中提出的。 Fielding是一个非常重要的人，他是HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席。所以，他的这篇论文一经发表，就引起了关注，并且立即对互联网开发产生了深远的影响。 他这样介绍论文写作的目的： 123&quot;本文研究计算机科学两大前沿----软件和网络----的交叉点。长期以来，软件研究主要关注软件设计的分类、设计方法的演化，很少客观地评估不同的设计选择对系统行为的影响。而相反地，网络研究主要关注系统之间通信行为的细节、如何改进特定通信机制的表现，常常忽视了一个事实，那就是改变应用程序的互动风格比改变互动协议，对整体表现有更大的影响。我这篇文章的写作目的，就是想在符合架构原理的前提下，理解和评估以网络为基础的应用软件的架构设计，得到一个功能强、性能好、适宜通信的架构。&quot;(This dissertation explores a junction on the frontiers of two research disciplines in computer science: software and networking. Software research has long been concerned with the categorization of software designs and the development of design methodologies, but has rarely been able to objectively evaluate the impact of various design choices on system behavior. Networking research, in contrast, is focused on the details of generic communication behavior between systems and improving the performance of particular communication techniques, often ignoring the fact that changing the interaction style of an application can have more impact on performance than the communication protocols used for that interaction. My work is motivated by the desire to understand and evaluate the architectural design of network-based application software through principled use of architectural constraints, thereby obtaining the functional, performance, and social properties desired of an architecture. ) 名称 Fielding将他对互联网软件的架构原则，定名为REST，即Representational State Transfer的缩写。我对这个词组的翻译是”表现层状态转化”。 如果一个架构符合REST原则，就称它为RESTful架构。 要理解RESTful架构，最好的方法就是去理解Representational State Transfer这个词组到底是什么意思，它的每一个词代表了什么涵义。如果你把这个名称搞懂了，也就不难体会REST是一种什么样的设计。 资源（Resources） REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层（Representation） “资源”是一种信息实体，它可以有多种外在表现形式。我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）。 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 状态转化（State Transfer） 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 综述 综合上面的解释，我们总结一下什么是RESTful架构： （1）每一个URI代表一种资源； （2）客户端和服务器之间，传递这种资源的某种表现层； （3）客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 误区 RESTful架构有一些典型的设计误区。 最常见的一种设计错误，就是URI包含动词。因为”资源”表示一种实体，所以应该是名词，URI不应该有动词，动词应该放在HTTP协议中。 举例来说，某个URI是/posts/show/1，其中show是动词，这个URI就设计错了，正确的写法应该是/posts/1，然后用GET方法表示show。 如果某些动作是HTTP动词表示不了的，你就应该把动作做成一种资源。比如网上汇款，从账户1向账户2汇款500元，错误的URI是： POST /accounts/1/transfer/500/to/2 正确的写法是把动词transfer改成名词transaction，资源不能是动词，但是可以是一种服务： POST /transaction HTTP/1.1 Host: 127.0.0.1 from=1&amp;to=2&amp;amount=500.00 另一个设计误区，就是在URI中加入版本号： http://www.example.com/app/1.0/foo http://www.example.com/app/1.1/foo http://www.example.com/app/2.0/foo 因为不同的版本，可以理解成同一种资源的不同表现形式，所以应该采用同一个URI。版本号可以在HTTP请求头信息的Accept字段中进行区分（参见Versioning REST Services）： Accept: vnd.example-com.foo+json; version=1.0 Accept: vnd.example-com.foo+json; version=1.1 Accept: vnd.example-com.foo+json; version=2.0]]></content>
      <tags>
        <tag>RESTful架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac&Linux命令自查]]></title>
    <url>%2F2018%2F07%2F15%2FMac-Linux%E5%91%BD%E4%BB%A4%E8%87%AA%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[Linux rm命令 删除文件夹 Linux删除目录很简单，很多人还是习惯用rmdir，不过一旦目录非空，就陷入深深的苦恼之中，现在使用rm -rf命令即可。 直接rm就可以了，不过要加两个参数-rf 即：rm -rf 目录名字 -r 就是向下递归，不管有多少级目录，一并删除 -f 就是直接强行删除，不作任何提示的意思 注意事项：使用这个rm -rf的时候一定要格外小心，linux没有回收站的 Linux ls命令 显示当前目录下非隐藏文件与目录: ls 12[root@localhost ~]# lsanaconda-ks.cfg install.log install.log.syslog satools 显示当前目录下包括影藏文件在内的所有文件列表:ls -a 123[root@localhost ~]# ls -a. anaconda-ks.cfg .bash_logout .bashrc install.log .mysql_history satools .tcshrc .vimrc.. .bash_history .bash_profile .cshrc install.log.syslog .rnd .ssh .viminfo 输出长格式列表:ls -l 12345[root@localhost ~]# ls -1anaconda-ks.cfginstall.loginstall.log.syslogsatools 水平输出文件列表:ls -m 123[root@localhost /]# ls -mbin,boot, data, dev, etc, home, lib, lost+found, media, misc, mnt, opt, proc, root, sbin, selinux, srv, sys, tmp, usr, var 最近修改的文件显示在最上面:ls -t 123[root@localhost /]# ls -ttmp root etc dev lib boot sys proc data home bin sbin usr var lost+found media mnt opt selinux srv misc 显示递归文件:ls -R 123456[root@localhost ~]# ls -R.:anaconda-ks.cfg install.log install.log.syslog satools./satools:black.txt freemem.sh iptables.sh lnmp.sh mysql php502_check.sh ssh_safe.sh -a：显示所有档案及目录（ls内定将档案名或目录名称为“.”的视为影藏，不会列出）；-A：显示除影藏文件“.”和“..”以外的所有文件列表；-C：多列显示输出结果。这是默认选项；-l：与“-C”选项功能相反，所有输出信息用单列格式输出，不输出为多列；-F：在每个输出项后追加文件的类型标识符，具体含义：“”表示具有可执行权限的普通文件，“/”表示目录，“@”表示符号链接，“|”表示命令管道FIFO，“=”表示sockets套接字。当文件为普通文件时，不输出任何标识符；-b：将文件中的不可输出的字符以反斜线“”加字符编码的方式输出；-c：与“-lt”选项连用时，按照文件状态时间排序输出目录内容，排序的依据是文件的索引节点中的ctime字段。与“-l”选项连用时，则排序的一句是文件的状态改变时间；-d：仅显示目录名，而不显示目录下的内容列表。显示符号链接文件本身，而不显示其所指向的目录列表；-f：此参数的效果和同时指定“aU”参数相同，并关闭“lst”参数的效果；-i：显示文件索引节点号（inode）。一个索引节点代表一个文件；–file-type：与“-F”选项的功能相同，但是不显示“”；-k：以KB（千字节）为单位显示文件大小；-l：以长格式显示目录下的内容列表。输出的信息从左到右依次包括文件名，文件类型、权限模式、硬连接数、所有者、组、文件大小和文件的最后修改时间等；-m：用“,”号区隔每个文件和目录的名称；-n：以用户识别码和群组识别码替代其名称；-r：以文件名反序排列并输出目录内容列表；-s：显示文件和目录的大小，以区块为单位；-t：用文件和目录的更改时间排序；-L：如果遇到性质为符号链接的文件或目录，直接列出该链接所指向的原始文件或目录；-R：递归处理，将指定目录下的所有文件及子目录一并处理；–full-time：列出完整的日期与时间；–color[=WHEN]：使用不同的颜色高亮显示不同类型的。 Mac SSH命令 1ssh root@ip -p 4567 用ssh连接服务器-p后面跟端口号 Mac scp命令 把本地文件copy到远程服务器上： 1scp &lt;local file&gt; &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; 把远程服务器上的文件copy到本地： 1scp &lt;remote user&gt;@&lt;remote machine&gt;:&lt;remote path&gt; &lt;local file&gt; -1 强制scp命令使用协议ssh1-2 强制scp命令使用协议ssh2-4 强制scp命令只使用IPv4寻址-6 强制scp命令只使用IPv6寻址-B 使用批处理模式（传输过程中不询问传输口令或短语）-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）-p 保留原文件的修改时间，访问时间和访问权限。-q 不显示传输进度条。-r 递归复制整个目录。-v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。-c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。-F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。-i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。-l limit 限定用户所能使用的带宽，以Kbit/s为单位。-o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，-P port 注意是大写的P, port是指定数据传输用到的端口号-S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac第一篇]]></title>
    <url>%2F2018%2F07%2F10%2FMac%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[我很开心呢 测试一下行不行 look more 好吗]]></content>
      <tags>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5-21学习小结]]></title>
    <url>%2F2018%2F05%2F21%2F5-21%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Normal equation 标准方程能够快速计算(在n相对较小的情况)出θ的值不需要迭代。 Gradient Descent Normal Equation Need to choose alpha No need to choose alpha Needs many iterations No need to iterate O (kn^2) O (n^3), need to calculate inverse of X^T*X Works well when n is large Slow if n is very large In practice, when n exceeds 10,000 it might be a good time to go from a normal solution to an iterative process. If X^T*X is noninvertible, the common causes might be having : Redundant features, where two features are very closely related (i.e. they are linearly dependent) Too many features (e.g. m ≤ n). In this case, delete some features or use “regularization” (to be explained in a later lesson).]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5-10学习小结]]></title>
    <url>%2F2018%2F05%2F10%2F5-10%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Model Representation 监督算法模型，给予一个训练数据集到学习算法，然后得到一个hypothesis(假设)函数 – 输入X值后能预测相应的Y值 Cost function 求出代价函数的最小值，对应的参数值就是假设函数的最佳参数。 等高线图，越往中心的弧圈代表代价函数J 的值越小。 Gradient descent algorithm(梯度下降算法) :=表示赋值运算符 如果系数偏大，导数为正数，系数会变小；反之，系数偏小，导数为负数，系数会变大。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.2学习小结]]></title>
    <url>%2F2018%2F05%2F02%2F5-2%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Supervised learning 给algorithm一个data set in which “right answers” given Regression: predict continuous valued output Classification = discrete valued output(0 or 1) Unsupervised learning just give algorithm a data set nothing else(no extra information)不知道数据集的意义 clustering algorithm 聚合算法 Cocktail party problem 鸡尾酒会算法 Octavediabetes]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bachelor, Master and Doctor]]></title>
    <url>%2F2018%2F05%2F02%2FBachelor-Master-and-Doctor%2F</url>
    <content type="text"><![CDATA[BA: 文学学士学位（Bachelor of Arts） BBA: 工商业管理学士学位(Bachelor of Business Administration) BS: 理学学士学位(Bachelor of sciense) MA：文学硕士学位(Master of Arts) MS：理学硕士学位(Master of Sciense) MBA：工商管理硕士学位(Master of Business Administration) PhD：哲学博士学位，文理科均可。(Doctor of Philosophy)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python简单爬虫爬取豆瓣影人照片]]></title>
    <url>%2F2018%2F03%2F18%2Fpython%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3%E5%BD%B1%E4%BA%BA%E7%85%A7%E7%89%87%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-from bs4 import BeautifulSoupimport requests, os, refrom urllib.parse import urljoin# 豆瓣图片爬虫class SpiderMain(object): # 获取该页面上单独图片页面的链接 def _get_new_urls(self, page_url, soup): new_urls = set() reg = r"https://movie.douban.com/celebrity/" + page_url.split('/')[4] + r"/photo/\d+/$" #正则表达式 links = soup.find_all('a', href=re.compile(reg)) for link in links: new_url = link['href'] new_full_url = urljoin(page_url, new_url) new_urls.add(new_full_url) return new_urls #获取该名人的姓名作为图片文件夹名 def _get_name(self, root_url): response = requests.get(root_url) html_cont = response.content soup = BeautifulSoup(html_cont, 'html.parser') name = soup.find("div", attrs=&#123;"id":"content"&#125;).h1.text.split()[0] return name # 爬图片开始喽 def crawl(self, root_url): dir_name = self._get_name(root_url) dirIsExist = os.path.exists(os.getcwd() + r'\\douban\\%s'%dir_name) #该文件夹是否存在 if not dirIsExist: os.makedirs(os.getcwd() + r'\\douban\\%s'%dir_name) #创建图片文件夹 os.chdir(os.path.join(os.getcwd(), r'douban\\%s'%dir_name)) #进入该文件夹 n = 1 #图片数量 page = 0 #图片页码 while page &lt; 2: url_ = root_url + "photos/?start=%d" % (page*40) html_cont = requests.get(url_).content soup = BeautifulSoup(html_cont, 'html.parser') urls = self._get_new_urls(url_, soup) for url in urls: pic_name = str(n) + '.jpg' img_url = "https://img1.doubanio.com/view/photo/l/public/p" + url.split('/')[6] + ".jpg" pic = requests.get(img_url) with open(pic_name, 'wb') as file: #open函数? file.write(pic.content) file.flush() file.close() print("Crawl " + str(n) + " : " + img_url) n += 1 page += 1 print("Crawl succeed !")if __name__=="__main__": root_url = "https://movie.douban.com/celebrity/%d/" % 1274424 #只需修改该影人的豆瓣ID obj_spider = SpiderMain() obj_spider.crawl(root_url)]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.17学习小结]]></title>
    <url>%2F2018%2F03%2F17%2Fpost3-17%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Anaconda是什么? 简而言之就是python+一堆用来数据处理的第三方包+python环境和这些包的管理器 1）Anaconda附带了一大批常用数据科学包，它附带了 conda、Python 和 150 多个科学包及其依赖项。因此你可以立即开始处理数据。 2）管理包Anaconda 是在conda（一个包管理器和环境管理器）上发展出来的。在数据分析中，你会用到很多第三方的包，而conda（包管理器）可以很好的帮助你在计算机上安装和管理这些包，包括安装、卸载和更新包。 3）管理环境比如你在A项目中用了 Python2，而新的项目B老大要求使用Python 3，而同时安装两个Python版本可能会造成许多混乱和错误。这时候conda就可以帮助你为不同的项目建立不同的运行环境。 Conda命令关于管理环境 1）创建环境 在终端中使用: 1conda create -nenv_name package_names 上面的命令中，env_name是设置环境的名称（-n 是指该命令后面的env_name是你要创建环境的名称），package_names 是你要安装在创建环境中的包名称。 2）创建环境时，可以指定要安装在环境中的 Python 版本 当你同时使用 Python 2.x 和Python 3.x 中的代码时这很有用。要创建具有特定 Python 版本的环境，例如创建环境名称为py3，并安装最新版本的Python3在终端中输入： 1conda create -n py3 python=3 或也可以这样创建环境名称为py2，并安装最新版本的Python2： 1conda create -n py2 python=2 因为我做的项目不同，有时候会用到Python2，还有时候会用到Python3。所以我在自己的计算机上创建了这两个环境，并分别取了这样的环境名称：py2,py3。这样我可以根据不同的项目轻松使用不同版本的python。 如果你要安装特定版本（例如 Python3.6），请使用 1conda create -n py python=3.6 3）进入和离开环境 在 Windows 上，你可以使用activate my_env进入。在 OSX/Linux 上使用 source activate my_env 进入环境。 离开： 在 Windows 上，终端中输入： deactivate 在 OSX/Linux 上 输入： source deactivate 4）列出环境 我有时候会忘记自己创建的环境名称，这时候用conda env list就可以列出你创建的所有环境。 你会看到环境的列表，而且你当前所在环境的旁边会有一个星号*。默认的环境（即当你不在选定环境中时使用的环境）名为root。 5）删除环境 如果你不再使用某个环境，可以使用conda env remove -n env_name删除指定的环境（在这里环境名为 env_name）。 Conda关于包的管理 1）安装包 在终端中键入： 1conda install package_name 例如，要安装 pandas，在终端中输入： 1conda install pandas 你还可以同时安装多个包。类似 conda install pandas numpy 的命令会同时安装所有这些包。还可以通过添加版本号（例如 conda install numpy=1.10）来指定所需的包版本。 conda 还会自动为你安装依赖项。例如，scipy 依赖于 numpy，因为它使用并需要 numpy。如果你只安装 scipy (conda install scipy)，则 conda 还会安装 numpy（如果尚未安装的话）。 2）卸载包 在终端中键入 ： 1conda remove package_names 上面命令中的package_names是指你要卸载包的名称，例如你想卸载pandas包：conda remove pandas 3）更新包 在终端中键入： 1conda update package_name 如果想更新环境中的所有包（这样做常常很有用），使用：conda update --all。 4）列出已安装的包 12#列出已安装的包conda list 如果不知道要找的包的确切名称，可以尝试使用 conda search search_term 进行搜索。例如，我知道我想安装numpy，但我不清楚确切的包名称。我可以这样尝试：conda search num。 python类中的普通方法，静态方法和类方法 （装饰器@classmethod 和@staticmethod） 12345678910111213141516class A(object): #普通方法 def foo(self,x): print "executing foo(%s,%s)"%(self,x) #类方法 @classmethod def class_foo(cls,x): print "executing class_foo(%s,%s)"%(cls,x) #静态方法 @staticmethod def static_foo(x): print "executing static_foo(%s)"%xa=A() 下面是一个对象实体调用方法的常用方式.对象实体a被隐藏的传递给了第一个参数. 12a.foo(1)# executing foo(&lt;__main__.A object at 0xb7dbef0c&gt;,1) 用classmethods装饰,隐藏的传递给第一个参数的是对象实体的类(class A)而不是self(实例对象). 12a.class_foo(1)# executing class_foo(&lt;class '__main__.A'&gt;,1) 你也可以用类调用class_foo.实际上,如果你把一些方法定义成classmethod,那么实际上你是希望用类来调用这个方法,而不是用这个类的实例来调用这个方法.A.foo(1)将会返回一个TypeError错误,A.class_foo(1)将会正常运行: 用staticmethods来装饰,不管传递给第一个参数的是self(对象实体)还是cls(类).它们的表现都一样: 12345a.static_foo(1)# executing static_foo(1)A.static_foo('hi')# executing static_foo(hi) foo只是个函数,但是当你调用a.foo的时候你得到的不仅仅是一个函数,你得到的是一个第一个参数绑定到a的”加强版”函数.foo需要两个参数,而a.foo仅仅需要一个参数. a绑定了foo.下面可以知道什么叫”绑定”了: 12print(a.foo)# &lt;bound method A.foo of &lt;__main__.A object at 0xb7d52f0c&gt;&gt; 如果使用a.class_foo,是A(类)绑定到了class_foo而不是a(对象实体). 12print(a.class_foo)# &lt;bound method type.class_foo of &lt;class '__main__.A'&gt;&gt; 最后剩下静态方法,说到底它就是一个方法.a.static_foo只是返回一个不带参数绑定的方法.A.static_foo和a.static_foo只需要一个参数. 12print(a.static_foo)# &lt;function static_foo at 0xb7d479cc&gt; 参考资料 conda官方命令文档 初学python者自学anaconda的正确姿势是什么？？ Python 中的 classmethod 和 staticmethod 有什么具体用途？ - 知乎 装饰器@staticmethod和@classmethod有什么区别_ _ Stackoverflow about Python]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Anaconda</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[演员的定义]]></title>
    <url>%2F2018%2F02%2F15%2F%E6%BC%94%E5%91%98%E7%9A%84%E5%AE%9A%E4%B9%89%2F</url>
    <content type="text"><![CDATA[花了些时间看完了今日影评·表演者言，节目分为10期，每期15分钟左右，节目发起人周迅（小迷弟）和一些老戏骨嘉宾一起来讲述他们对演员的理解和演员所需要的能力和品质。 节目虽短，但内容却十分充实。周迅和这些优秀的演员都能很真诚地描述他们的经历经验以及对演员的理解。他们作为过来人，很多东西都值得年轻演员学习和参考。 对于一名优秀的演员来说，TA需要拥有什么呢？ 体验生活最重要也是最根本的一点，作为一个演员，最好的表演往往是最真实的。 表演源自于生活，好的演员能呈献给观众生活中的点滴和细节。而这些细腻的东西都需要人从生活体验并积累。种种经历会不断丰富你的阅历，阅历会让表演充实和真实。所以说最好的表演也是无表演，它就像是生活中真真实实发生的事。 观察生活身边的每一个人，每一件事都可以是电影中的一部分。而观察人物的一举一动和事件的发展过程，是提升演员自身对角色和故事理解的重要方法。因为作品中的每个角色往往都能在现实中找到类似的模板。 当你对演绎某个角色感到困惑的时候，现实生活往往会给你答案。察言观色是理解一个角色的必备技能。 学习互补向优秀演员取经，吸收他们的优点，相互促进，提升自己。通过一部又一部的作品去学习每个方面，从导演角度从各个角度去审视作品。 理性之中融入感性演员到头来还是要由理性主导的。在尊重作品，尊重人物的前提下加入演员的主观想法（自身理解）是角色演绎的最高境界。 感性至上带来的结果往往就是极端表现，角色的特征被演员自身特点代替或是角色形象是演员自己处理后模样。这会使角色带上个人情感色彩，可能不利于角色和作品本身。但也有一些情况是，在演员自身极具天赋的情况下，感性演绎会给角色附上一个独特色彩，让角色升华。这样的情况往往会出现在一些非科班出身的演员上。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[未来七日计划]]></title>
    <url>%2F2018%2F01%2F31%2Fplan%2F</url>
    <content type="text"><![CDATA[计划flag写一点简单的hexo入门教程 hexo+github搭建个人博客入门（自己学习心得） 关于hexo的备份（在github上再创建一个备份branch，因为hexo d deploy上去的只是网页的静态文件不是hexo项目整个文件夹） 先这样吧 资料hexo备份 使用hexo，如果换了电脑怎么更新博客？ - CrazyMilk的回答 - 知乎 手把手教你用Hexo+Github 搭建属于自己的博客 GitHub+Hexo 搭建个人网站详细教程]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typora-学习笔记]]></title>
    <url>%2F2018%2F01%2F30%2FTypora%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[字体斜体 * *加粗 ** ** 或者__ __下划线 &lt;u&gt; &lt;/u&gt;删除线 ~~ ~~代码块1print('hello world!') 1System.out.println("Hello World!"); 123​```语言balabala 有序列表 一一 二二 三三 1231. 112. 223. 33 无序列表 周 冬 雨 1234- 小- 黄- 鸭-,+,*皆可 链接这个是链接啊 &lt;www.baidu.com&gt; 12[word](link)&lt;link&gt; 引用 第一级引用 第二级 第三级 123&gt; 1 &gt; 2 &gt; 3 居中居中了吗？ 1&lt;center&gt;居中了啦~&lt;/center&gt; 标注（Hexo不支持T_T）Example[^1] [^1]: this is a note 12某些人用过了才知道[^注释][^注释]:Somebody that I used to know. 表格 周 冬 雨 郑 茅 炜 在 一 起 快捷键Ctrl+T 图片插入 12![ALT](image.jpg 图片介绍)&#123;% asset_img 图片ALT pic.jpg 图片介绍 %&#125; 多选框（任务列表）-[ ] 文字—–代表没有选中的复选框 -[x] 文字——代表选中的复选框 -[x] 数学 -[ ] 英语 1234567-[空格]空格 文字—–代表没有选中的复选框-[x]空格 文字——代表选中的复选框-[x] 数学-[ ] 英语 常用快捷键加粗：Ctrl+B 斜体：Ctrl+I 字体：Ctrl+数字 下划线：Ctrl+U 返回开头：Ctrl+Home 返回结尾：Ctrl+End 生成表格：Ctrl+T 创建链接：Ctrl+K ReferencesTypora学习笔记 - CSDN博客 Markdown的常用语法(个人总结) - 简书 Hexo博客搭建之在文章中插入图片]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Typora</tag>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重庆森林]]></title>
    <url>%2F2018%2F01%2F30%2F%E9%87%8D%E5%BA%86%E6%A3%AE%E6%9E%97%2F</url>
    <content type="text"><![CDATA[​ “发胖的肥皂，流泪的毛巾 和30个凤梨罐头。” 人的一生啊人的一生就是无数经历 感谢那些让你拥有经历的人 无论经历是好是坏结果是悲是喜 它会是人生中最珍贵的东西 为什么很多时候一些作品映入眼帘却毫无头绪 想想其实道理很简单 缺少阅历 缺少经历 缺少积累 一旦你的大脑中有类似的记忆 作品往往触发这些记忆 所谓感同身受 这就是经历的宝贵之处 而它是不可能用物质或者任何东西去换 去买 所以啊 人越是成长越是要学会感恩 不光光是对那些帮助过你的人 还有那些带给你经历的人 人与人之间我们每个人其实一直都在潜移默化地改变 没有改变永远都是相对而言罢了 这个世界 那些你身边的人 都是你自己化学反应的催化剂 而你也是他们的催化剂 人与人之间往往就是这样一个微妙的关系 如同王吉民老师说的 ‘恋爱的过程就是两个互相学习’ 到最后往往对方都会慢慢变成自己的模样或者自己喜欢的样子 重庆的森林当然多愁善感没人能避免 发胖的肥皂和流泪的毛巾 30个凤梨罐头 人容易被感情驱使 这是人最有趣的特点了吧重庆森林每个阶段都会产生每种感受 就像我上面说的 经历决定感受 情感产生经历 这就是人生]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[test_my_site]]></title>
    <url>%2F2018%2F01%2F30%2Ftest-my-site%2F</url>
    <content type="text"><![CDATA[继续测试继续测试]]></content>
      <categories>
        <category>测试分类</category>
      </categories>
      <tags>
        <tag>测试标签</tag>
      </tags>
  </entry>
</search>
